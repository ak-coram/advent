(ql:quickload :fset)

(defun day09 (is-part-two)
  (labels
      ((resize-file (disk position new-size)
         (let* ((file (fset:lookup disk position))
                (additional-space (- (cdr file) new-size))
                (resized-disk
                  (if (plusp additional-space)
                      (fset:insert disk (1+ position) additional-space)
                      disk)))
           (if (plusp new-size)
               (fset:with resized-disk position (cons (car file) new-size))
               (fset:less resized-disk position))))
       (create-file (disk position file)
         (let* ((space-size (fset:lookup disk position))
                (disk-with-file (fset:insert disk position file))
                (remaining-space (- space-size (cdr file))))
           (if (plusp remaining-space)
               (fset:with disk-with-file (1+ position) remaining-space)
               (fset:less disk-with-file (1+ position)))))
       (move (disk file-position space-position)
         (let* ((space-size (fset:lookup disk space-position))
                (file (fset:lookup disk file-position))
                (file-size (cdr file)))
           (create-file (resize-file disk
                                     file-position
                                     (max (- file-size space-size) 0))
                        space-position
                        (cons (car file) (min file-size space-size)))))
       (find-unprocessed-file (disk processed-ids)
         (fset:position-if
          (lambda (entry) (and (consp entry)
                               (not (fset:member? (car entry)
                                                  processed-ids))))
          disk :from-end t))
       (find-space (disk min-size)
         (fset:position-if (lambda (entry) (and (numberp entry)
                                                (>= entry min-size)))
                           disk))
       (pack-v1 (disk)
         (let ((space-position (find-space disk 1))
               (file-position (find-unprocessed-file disk (fset:empty-set))))
           (if (or (not space-position) (< file-position space-position))
               disk
               (pack-v1 (move disk file-position space-position)))))
       (pack-v2 (disk &optional (processed-ids (fset:empty-set)))
         (let ((file-position (find-unprocessed-file disk processed-ids)))
           (if file-position
               (let* ((file (fset:lookup disk file-position))
                      (file-id (car file)) (file-size (cdr file))
                      (space-position (find-space disk file-size)))
                 (pack-v2 (if (and space-position
                                   (< space-position file-position))
                              (move disk file-position space-position)
                              disk)
                          (fset:with processed-ids file-id)))
               disk)))
       (checksum (disk) (let ((checksum 0) (block-index 0))
                          (fset:do-seq (entry disk)
                            (if (consp entry)
                                (dotimes (_ (cdr entry))
                                  (incf checksum (* block-index (car entry)))
                                  (incf block-index))
                                (incf block-index entry)))
                          checksum)))
    (loop :with input-chars := (coerce (uiop:read-file-line #P"./09.txt") 'list)
          :and disk := (fset:empty-seq)
          :for (file . (space)) :on input-chars :by #'cddr
          :for space-size := (if space (digit-char-p space) 0)
          :for file-id :from 0
          :do (fset:push-last disk (cons file-id (digit-char-p file)))
          :when (plusp space-size)
            :do (fset:push-last disk space-size)
          :finally (return (checksum (if is-part-two
                                         (pack-v2 disk)
                                         (pack-v1 disk)))))))
