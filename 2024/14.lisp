(ql:quickload '(:cl-ppcre :fset))

(defun day14 (is-part-two)
  (let* ((robots) (width 101) (height 103)
         (qx (floor width 2)) (qy (floor height 2)))
    (dolist (line (uiop:read-file-lines #P"./14.txt"))
      (ppcre:register-groups-bind ((#'parse-integer px py vx vy))
          ("p=(-?\\d+),(-?\\d+) v=(-?\\d+),(-?\\d+)" line)
        (push (list (cons px py) (cons vx vy)) robots)))
    (labels ((move (robot n)
               (destructuring-bind (p v) robot
                 (let* ((x (car p)) (y (cdr p))
                        (dx (* n (car v))) (dy (* n (cdr v))))
                   (cons (mod (+ x dx) width)
                         (mod (+ y dy) height)))))
             (get-quadrant (p) (let ((x (car p)) (y (cdr p)))
                                 (cond ((and (< x qx) (< y qy)) 1)
                                       ((and (< qx x) (< y qy)) 2)
                                       ((and (< x qx) (< qy y)) 3)
                                       ((and (< qx x) (< qy y)) 4))))
             (variance (positions)
               (let* ((n (fset:size positions))
                      (sums (fset:reduce (lambda (acc position)
                                           (cons (+ (car acc) (car position))
                                                 (+ (cdr acc) (cdr position))))
                                         positions
                                         :initial-value (cons 0 0)))
                      (x-sum (car sums)) (y-sum (cdr sums))
                      (x-mean (/ x-sum n)) (y-mean (/ y-sum n))
                      (result 0))
                 (fset:do-set (position positions result)
                   (let* ((x (car position)) (y (cdr position))
                          (dx (- x x-mean)) (dy (- y y-mean)))
                     (incf result (/ (* dx dx) n))
                     (incf result (/ (* dy dy) n))))))
             (robot-positions (n)
               (loop :with positions := (fset:empty-set)
                     :for robot :in robots
                     :do (fset:includef positions (move robot n))
                     :finally (return positions))))
      (if is-part-two
          (loop :with variances := (fset:empty-map)
                :for n :from 0 :for positions := (robot-positions n)
                :until (fset:lookup variances positions)
                :do (fset:includef variances positions
                                   (cons (variance positions) n))
                :finally (return (cdr (fset:least (fset:range variances)))))
          (loop :with quadrants := (fset:empty-bag) :and safety-factor := 1
                :for robot :in robots
                :for quadrant := (get-quadrant (move robot 100))
                :when quadrant
                  :do (fset:includef quadrants quadrant)
                :finally (return
                           (fset:do-bag-pairs (_ n quadrants safety-factor)
                             (declare (ignore _))
                             (setf safety-factor (* safety-factor n)))))))))
