(ql:quickload :fset)

(defun day04 (is-part-two)
  (labels ((get-initial-rolls ()
             (loop :with rolls := (fset:empty-set)
                   :for line :in (uiop:read-file-lines #P"./04.txt")
                   :for y :from 0
                   :do (loop :for c :across line :for x :from 0
                             :when (eql c #\@)
                               :do (fset:includef rolls (cons x y)))
                   :finally (return rolls)))
           (get-adjacent-rolls (rolls roll)
             (let ((x (car roll)) (y (cdr roll)))
               (fset:intersection
                rolls (fset:set (cons (1- x) (1- y)) (cons x (1- y))
                                (cons (1+ x) (1- y)) (cons (1+ x) y)
                                (cons (1+ x) (1+ y)) (cons x (1+ y))
                                (cons (1- x) (1+ y)) (cons (1- x) y)))))
           (get-accessible (rolls &optional (candidates rolls))
             (let ((accessible-rolls (fset:empty-set))
                   (new-candidates (fset:empty-set)))
               (fset:do-set (roll candidates)
                 (let ((neighbours (get-adjacent-rolls rolls roll)))
                   (when (< (fset:size neighbours) 4)
                     (fset:includef accessible-rolls roll)
                     (fset:unionf new-candidates neighbours))))
               (values accessible-rolls
                       (fset:set-difference new-candidates accessible-rolls)))))
    (loop :for rolls := (get-initial-rolls)
            :then (fset:set-difference rolls removable-rolls)
          :for candidates := rolls :then new-candidates
          :for (removable-rolls new-candidates)
            := (multiple-value-list (get-accessible rolls candidates))
          :sum (fset:size removable-rolls)
          :until (or (fset:empty? removable-rolls) (not is-part-two)))))
