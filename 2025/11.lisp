(ql:quickload '(:cl-ppcre :fset))

(defun day11 (is-part-two)
  (let ((nodes (fset:empty-set))
        (network (fset:empty-map (fset:empty-set)))
        (input-counts (fset:empty-map 0))
        (output-only-nodes (fset:empty-set))
        (ordered-nodes (fset:empty-seq)))
    (loop :for line :in (uiop:read-file-lines #P"./11.txt")
          :for (s outputs) := (ppcre:split ": " line)
          :for source := (intern s)
          :do (fset:includef nodes source)
          :do (loop :with result := (fset:empty-set)
                    :for o :in (ppcre:split " " outputs)
                    :for output := (intern o)
                    :do (fset:includef nodes output)
                    :do (fset:includef result output)
                    :finally (fset:includef network source result)))
    ;; Toposort
    (fset:do-set (node nodes)
      (fset:do-set (output (fset:lookup network node))
        (incf (fset:lookup input-counts output))))
    (fset:do-set (node nodes)
      (when (zerop (fset:lookup input-counts node))
        (fset:includef output-only-nodes node)))
    (loop :with queue := (fset:convert 'fset:seq output-only-nodes)
          :for node := (fset:pop-first queue)
          :while node
          :do (fset:push-last ordered-nodes node)
          :do (fset:do-set (output (fset:lookup network node))
                (setf input-counts (fset:update #'1- input-counts output))
                (when (zerop (fset:lookup input-counts output))
                  (fset:push-last queue output))))

    (labels ((path-counts (source target)
               (let ((counts (fset:empty-map 0)))
                 (fset:includef counts source 1)
                 (fset:do-seq (node ordered-nodes)
                   (let ((count (fset:lookup counts node)))
                     (fset:do-set (output (fset:lookup network node))
                       (setf counts (fset:update (lambda (n) (+ n count))
                                                 counts
                                                 output)))))
                 (fset:lookup counts target)))
             (out-path-counts (target)
               (let ((counts (fset:empty-map 0)))
                 (fset:includef counts '|out| 1)
                 (fset:do-seq (node (fset:reverse ordered-nodes))
                   (fset:do-set (output (fset:lookup network node))
                     (let ((count (fset:lookup counts output)))
                       (setf counts (fset:update (lambda (n) (+ n count))
                                                 counts
                                                 node)))))
                 (fset:lookup counts target))))
      (if is-part-two
          (let ((srv->dac (path-counts '|svr| '|dac|))
                (srv->fft (path-counts '|svr| '|fft|))
                (dac->fft (path-counts '|dac| '|fft|))
                (fft->dac (path-counts '|fft| '|dac|))
                (dac->out (out-path-counts '|dac|))
                (fft->out (out-path-counts '|fft|)))
            (+ (* srv->dac dac->fft fft->out)
               (* srv->fft fft->dac dac->out)))
          (nth-value 0 (out-path-counts '|you|))))))
